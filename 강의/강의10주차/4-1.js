// 냅색 알고리즘
// 동적 프로그래밍을 이용한 방법
// dy라는 배열을 이용해 푼다.
// dy배열은 거스름돈(m)만큼의 크기를 갖는다.
// dy배열의 각 값은 최대 거스름돈을 거슬러주는 동전의 수 + 1만큼으로 충분히 큰 값으로 초기화한다.
// 이제 dy배열에서 각 숫자를 반복한다.
// 이중 for문으로 동전의 종류도 반복한다.
// dy[0] = 1로 초기화한다.
// 첫 번째 동전을 1원이라 했을 때, dy[1] = 1로 값이 책정된다.
// dy[2] = 2, dy[3] = 3, ... dy[15] = 15가 된다. 즉 i = 1씩증가하는 거스름돈이다.
// j = 1일 때, 동전의 종류는 3원으로 바뀐다. dy[1], dy[2]는 해당사항이 없다. 따라서
// i = arr[j]에서 시작해야한다.
// dy[3] = 1 동전 3으로 한 번 거슬러 줄 수 있다. 그러면 dy[3] = 1로 값을 바꿔주고(이전 값 : dy[3] = 3)
// dy[4] = 2 동전 3 한 개와 동전 1 한 개로 거슬러 줄수 있어 2개이다. 즉 dy[i] = dy[i - coin[j]] (=1) + 1이된다.(마지막 +1은 돌고있는 동전의 개수)
// dy[5] = 3 동전 3 한 개와 동전 1 두 개로 거슬러 줄 수 있어 3개이다. dy[i] = dy[i -coin[j]] (=2, dy[2] = 2) + 1이 된다.


function solution(n, m, coin) {
    let answer = 0;
    const dy = Array.from({length:m + 1}, () => 501);
    dy[0] = 0;
    for(let i = 0; i < n; i++) { // 동전 종류 반복
        for(let j = coin[i]; j <= m; j++) { // 거스름돈 dy반복
            dy[j] = Math.min(dy[j], dy[j - coin[i]] + 1)
        }
    }
    answer = dy[m]
    return answer;
}

const coin = [1, 3, 5]
console.log(solution(3, 15, coin))